// TODO: #![deny(missing_docs)]
// Deny warnings in doc test.
#![doc(test(attr(deny(warnings))))]
#![doc = include_str!("../README.md")]

pub mod value;
#[doc(inline)]
pub use value::{from_value, from_value_ref, to_value, AnnotatedValue, Value};

mod num_bool;
#[doc(inline)]
pub use num_bool::{
    Bool, Float32, Float64, Int16, Int32, Int64, Int8, Number, UInt16, UInt32, UInt64, UInt8,
};

mod option;
#[doc(inline)]
pub use option::Option;

mod string;
#[doc(inline)]
pub use string::String;

mod raw;
#[doc(inline)]
pub use raw::Raw;

mod tuple;
#[doc(inline)]
pub use tuple::{Tuple, Unit};

// The module is not named `type` because it is a keyword.
mod typing;
#[doc(inline)]
pub use typing::{Annotations as TypeAnnotations, Type};

mod signature;
#[doc(inline)]
pub use signature::Signature;

mod read;

pub mod ser;
#[doc(inline)]
pub use ser::*;

pub mod de;
#[doc(inline)]
pub use de::*;

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("the value '{0}' is not a `bool` value")]
    NotABoolValue(u8),

    #[error("cannot deserialize any data, the type information of the expected value is required (the `qi` format is not self-describing)")]
    CannotDeserializeAny,

    #[error("bad size: {0}")]
    BadSize(std::num::TryFromIntError),

    #[error("list and maps size must be known to be serialized")]
    SizeIsRequired,

    #[error("expected {0} elements, got one more")]
    UnexpectedElement(usize),

    #[error("string data is not valid UTF-8: {0}")]
    InvalidStringUtf8(#[from] std::str::Utf8Error),

    #[error("{0}")]
    Custom(std::string::String),
}

pub type Result<T> = std::result::Result<T, Error>;

#[cfg(test)]
mod tests {
    use super::*;
    use pretty_assertions::assert_eq;
    use std::collections::BTreeMap;

    #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
    struct S0 {
        u: (),
        t: (i8, u8, i16, u16, i32, u32, i64, u64, f32, f64),
        #[serde(with = "serde_bytes")]
        r: Vec<u8>,
        o: std::option::Option<bool>,
        s: S1,
        l: Vec<std::string::String>,
        m: BTreeMap<i32, std::string::String>,
    }

    #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
    struct S1(std::string::String, std::string::String);

    #[derive(serde::Serialize, serde::Deserialize, Debug, PartialEq)]
    pub struct Serializable(S0);

    impl Serializable {
        pub fn sample() -> Self {
            Self(S0 {
                u: (),
                t: (-8, 8, -16, 16, -32, 32, -64, 64, 32.32, 64.64),
                r: vec![51, 52, 53, 54],
                o: Some(false),
                s: S1("bananas".to_string(), "oranges".to_string()),
                l: vec!["cookies".to_string(), "muffins".to_string()],
                m: {
                    let mut m = BTreeMap::new();
                    m.insert(1, "hello".to_string());
                    m.insert(2, "world".to_string());
                    m
                },
            })
        }

        pub fn sample_as_value() -> Value<'static> {
            use {num_bool::*, value::*};
            let unit = Value::unit();
            let tuple = Value::from(Tuple::new(vec![
                Value::from(Number::Int8(-8)),
                Value::from(Number::UInt8(8)),
                Value::from(Number::Int16(-16)),
                Value::from(Number::UInt16(16)),
                Value::from(Number::Int32(-32)),
                Value::from(Number::UInt32(32)),
                Value::from(Number::Int64(-64)),
                Value::from(Number::UInt64(64)),
                Value::from(Number::from(Float32::from(32.32))),
                Value::from(Number::from(Float64::from(64.64))),
            ]));
            let raw = Value::from(Raw::from(vec![51, 52, 53, 54]));
            let opt = Value::from(Some(Value::from(false)));
            let s1 = Tuple::new(vec![Value::from("bananas"), Value::from("oranges")]);
            let structure = Value::from(s1);
            let list = Value::from(vec![Value::from("cookies"), Value::from("muffins")]);
            let map = Value::Map(Map::from(vec![
                (Value::from(1i32), Value::from("hello")),
                (Value::from(2i32), Value::from("world")),
            ]));
            let s0 = Value::from(Tuple::new(vec![
                unit, tuple, raw, opt, structure, list, map,
            ]));
            Value::from(Tuple::new(vec![s0]))
        }
    }

    #[test]
    fn test_to_from_bytes_serializable() {
        let sample = Serializable::sample();
        let bytes = to_bytes(&sample).unwrap();
        let sample2: Serializable = from_bytes(&bytes).unwrap();
        assert_eq!(sample, sample2);
    }

    // Tuple size is not prepended.
    #[test]
    fn test_tuple_to_bytes() {
        assert_eq!(
            to_bytes(&(42u16, "str", true)).unwrap(),
            vec![
                42, 0, // u16
                3, 0, 0, 0, 0x73, 0x74, 0x72, // string, prepended with its length
                1     // bool
            ]
        );
    }

    #[test]
    fn test_metaobject_value_from_bytes() {
        // A MetaObject taken from a TCP dump of libqi tests.
        let bytes = vec![
            0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x4c, 0x0d, 0x00, 0x00, 0x00, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
            0x72, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x05, 0x00, 0x00, 0x00, 0x28, 0x49, 0x49, 0x4c,
            0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x76, 0x0f, 0x00,
            0x00, 0x00, 0x75, 0x6e, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x45, 0x76,
            0x65, 0x6e, 0x74, 0x05, 0x00, 0x00, 0x00, 0x28, 0x49, 0x49, 0x4c, 0x29, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00, 0x1f, 0x01, 0x00, 0x00, 0x28, 0x7b, 0x49, 0x28, 0x49, 0x73,
            0x73, 0x73, 0x73, 0x5b, 0x28, 0x73, 0x73, 0x29, 0x3c, 0x4d, 0x65, 0x74, 0x61, 0x4d,
            0x65, 0x74, 0x68, 0x6f, 0x64, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72,
            0x2c, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
            0x69, 0x6f, 0x6e, 0x3e, 0x5d, 0x73, 0x29, 0x3c, 0x4d, 0x65, 0x74, 0x61, 0x4d, 0x65,
            0x74, 0x68, 0x6f, 0x64, 0x2c, 0x75, 0x69, 0x64, 0x2c, 0x72, 0x65, 0x74, 0x75, 0x72,
            0x6e, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x6e, 0x61, 0x6d,
            0x65, 0x2c, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x53, 0x69,
            0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
            0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65,
            0x72, 0x73, 0x2c, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x44, 0x65, 0x73, 0x63, 0x72,
            0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x3e, 0x7d, 0x7b, 0x49, 0x28, 0x49, 0x73, 0x73,
            0x29, 0x3c, 0x4d, 0x65, 0x74, 0x61, 0x53, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x2c, 0x75,
            0x69, 0x64, 0x2c, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74,
            0x75, 0x72, 0x65, 0x3e, 0x7d, 0x7b, 0x49, 0x28, 0x49, 0x73, 0x73, 0x29, 0x3c, 0x4d,
            0x65, 0x74, 0x61, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x2c, 0x75, 0x69,
            0x64, 0x2c, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75,
            0x72, 0x65, 0x3e, 0x7d, 0x73, 0x29, 0x3c, 0x4d, 0x65, 0x74, 0x61, 0x4f, 0x62, 0x6a,
            0x65, 0x63, 0x74, 0x2c, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x73, 0x2c, 0x73, 0x69,
            0x67, 0x6e, 0x61, 0x6c, 0x73, 0x2c, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69,
            0x65, 0x73, 0x2c, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
            0x3e, 0x0a, 0x00, 0x00, 0x00, 0x6d, 0x65, 0x74, 0x61, 0x4f, 0x62, 0x6a, 0x65, 0x63,
            0x74, 0x03, 0x00, 0x00, 0x00, 0x28, 0x49, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x76, 0x09, 0x00, 0x00, 0x00, 0x74, 0x65, 0x72, 0x6d, 0x69,
            0x6e, 0x61, 0x74, 0x65, 0x03, 0x00, 0x00, 0x00, 0x28, 0x49, 0x29, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6d, 0x08, 0x00, 0x00, 0x00, 0x70, 0x72,
            0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x03, 0x00, 0x00, 0x00, 0x28, 0x6d, 0x29, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00,
            0x00, 0x06, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x76, 0x0b, 0x00, 0x00, 0x00,
            0x73, 0x65, 0x74, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x04, 0x00, 0x00,
            0x00, 0x28, 0x6d, 0x6d, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
            0x00, 0x5b, 0x73, 0x5d, 0x0a, 0x00, 0x00, 0x00, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72,
            0x74, 0x69, 0x65, 0x73, 0x02, 0x00, 0x00, 0x00, 0x28, 0x29, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x4c, 0x1a, 0x00, 0x00, 0x00, 0x72, 0x65, 0x67,
            0x69, 0x73, 0x74, 0x65, 0x72, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x57, 0x69, 0x74, 0x68,
            0x53, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x06, 0x00, 0x00, 0x00, 0x28,
            0x49, 0x49, 0x4c, 0x73, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
            0x00, 0x62, 0x0e, 0x00, 0x00, 0x00, 0x69, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x45,
            0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x02, 0x00, 0x00, 0x00, 0x28, 0x29, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00,
            0x51, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x76, 0x0b, 0x00, 0x00, 0x00, 0x65,
            0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73, 0x03, 0x00, 0x00, 0x00,
            0x28, 0x62, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x52, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x7b,
            0x49, 0x28, 0x49, 0x28, 0x66, 0x66, 0x66, 0x29, 0x3c, 0x4d, 0x69, 0x6e, 0x4d, 0x61,
            0x78, 0x53, 0x75, 0x6d, 0x2c, 0x6d, 0x69, 0x6e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2c,
            0x6d, 0x61, 0x78, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2c, 0x63, 0x75, 0x6d, 0x75, 0x6c,
            0x61, 0x74, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x3e, 0x28, 0x66, 0x66, 0x66,
            0x29, 0x3c, 0x4d, 0x69, 0x6e, 0x4d, 0x61, 0x78, 0x53, 0x75, 0x6d, 0x2c, 0x6d, 0x69,
            0x6e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2c, 0x6d, 0x61, 0x78, 0x56, 0x61, 0x6c, 0x75,
            0x65, 0x2c, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x56, 0x61, 0x6c,
            0x75, 0x65, 0x3e, 0x28, 0x66, 0x66, 0x66, 0x29, 0x3c, 0x4d, 0x69, 0x6e, 0x4d, 0x61,
            0x78, 0x53, 0x75, 0x6d, 0x2c, 0x6d, 0x69, 0x6e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2c,
            0x6d, 0x61, 0x78, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2c, 0x63, 0x75, 0x6d, 0x75, 0x6c,
            0x61, 0x74, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x3e, 0x29, 0x3c, 0x4d, 0x65,
            0x74, 0x68, 0x6f, 0x64, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73,
            0x2c, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x2c, 0x77, 0x61, 0x6c, 0x6c, 0x2c, 0x75, 0x73,
            0x65, 0x72, 0x2c, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x3e, 0x7d, 0x05, 0x00, 0x00,
            0x00, 0x73, 0x74, 0x61, 0x74, 0x73, 0x02, 0x00, 0x00, 0x00, 0x28, 0x29, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00,
            0x53, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x76, 0x0a, 0x00, 0x00, 0x00, 0x63,
            0x6c, 0x65, 0x61, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x02, 0x00, 0x00, 0x00, 0x28,
            0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
            0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x62, 0x0e, 0x00,
            0x00, 0x00, 0x69, 0x73, 0x54, 0x72, 0x61, 0x63, 0x65, 0x45, 0x6e, 0x61, 0x62, 0x6c,
            0x65, 0x64, 0x02, 0x00, 0x00, 0x00, 0x28, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x76, 0x0b, 0x00, 0x00, 0x00, 0x65, 0x6e, 0x61, 0x62, 0x6c,
            0x65, 0x54, 0x72, 0x61, 0x63, 0x65, 0x03, 0x00, 0x00, 0x00, 0x28, 0x62, 0x29, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
            0x00, 0x64, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x76, 0x03, 0x00, 0x00, 0x00,
            0x73, 0x65, 0x74, 0x03, 0x00, 0x00, 0x00, 0x28, 0x6f, 0x29, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x65, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6f, 0x03, 0x00, 0x00, 0x00, 0x67, 0x65, 0x74,
            0x02, 0x00, 0x00, 0x00, 0x28, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x6f, 0x10, 0x00, 0x00, 0x00, 0x67, 0x65, 0x74, 0x48, 0x6f, 0x6d, 0x65,
            0x4d, 0x61, 0x64, 0x65, 0x48, 0x75, 0x6d, 0x61, 0x6e, 0x02, 0x00, 0x00, 0x00, 0x28,
            0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67,
            0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x76, 0x11, 0x00,
            0x00, 0x00, 0x65, 0x6d, 0x69, 0x74, 0x48, 0x75, 0x6d, 0x61, 0x6e, 0x50, 0x72, 0x6f,
            0x70, 0x65, 0x72, 0x74, 0x79, 0x02, 0x00, 0x00, 0x00, 0x28, 0x29, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x56,
            0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x74, 0x72, 0x61,
            0x63, 0x65, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x8b, 0x00, 0x00, 0x00, 0x28, 0x28,
            0x49, 0x69, 0x49, 0x6d, 0x28, 0x6c, 0x6c, 0x29, 0x3c, 0x74, 0x69, 0x6d, 0x65, 0x76,
            0x61, 0x6c, 0x2c, 0x74, 0x76, 0x5f, 0x73, 0x65, 0x63, 0x2c, 0x74, 0x76, 0x5f, 0x75,
            0x73, 0x65, 0x63, 0x3e, 0x6c, 0x6c, 0x49, 0x49, 0x29, 0x3c, 0x45, 0x76, 0x65, 0x6e,
            0x74, 0x54, 0x72, 0x61, 0x63, 0x65, 0x2c, 0x69, 0x64, 0x2c, 0x6b, 0x69, 0x6e, 0x64,
            0x2c, 0x73, 0x6c, 0x6f, 0x74, 0x49, 0x64, 0x2c, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65,
            0x6e, 0x74, 0x73, 0x2c, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2c,
            0x75, 0x73, 0x65, 0x72, 0x55, 0x73, 0x54, 0x69, 0x6d, 0x65, 0x2c, 0x73, 0x79, 0x73,
            0x74, 0x65, 0x6d, 0x55, 0x73, 0x54, 0x69, 0x6d, 0x65, 0x2c, 0x63, 0x61, 0x6c, 0x6c,
            0x65, 0x72, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x2c, 0x63, 0x61, 0x6c, 0x6c,
            0x65, 0x65, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x3e, 0x29, 0x68, 0x00, 0x00,
            0x00, 0x68, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x68, 0x75, 0x6d, 0x61, 0x6e,
            0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x03, 0x00, 0x00, 0x00, 0x28, 0x6f,
            0x29, 0x01, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x0d,
            0x00, 0x00, 0x00, 0x68, 0x75, 0x6d, 0x61, 0x6e, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72,
            0x74, 0x79, 0x01, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x00, 0x00, 0x00,
        ];
    }

    #[test]
    fn test_annotated_value_from_bytes() {
        let bytes = [
            0x01, 0x00, 0x00, 0x00, 0x73, 0x1a, 0x00, 0x00, 0x00, 0x54, 0x68, 0x65, 0x20, 0x72,
            0x6f, 0x62, 0x6f, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x6f,
            0x63, 0x61, 0x6c, 0x69, 0x7a, 0x65, 0x64,
        ];
        let value: Value = from_bytes(&bytes).unwrap();
        assert_eq!(
            value,
            Value::from(String::from("The robot is not localized"))
        );
    }

    #[test]
    fn test_to_from_bytes_annotated_value() {
        let value_before = AnnotatedValue::new(Serializable::sample_as_value());
        let bytes = to_bytes(&value_before).unwrap();
        let value_after: AnnotatedValue = from_bytes(&bytes).unwrap();
        assert_eq!(value_before, value_after);
    }
}
